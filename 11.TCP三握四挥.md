## TCP三握四挥？
即TCP三次握手、四次挥手。三次握手用于建立TCP连接，四次挥手用于销毁TCP连接

由于篇幅可能较长，建议反复斟酌
### 三次握手
1. 客户端主动开启TCP连接，并发送一个TCP连接请求报文，这个报文有这些字段（注：TCP报文字段有好几个，这里主要讲的是建立连接时主要用到的字段），SYN = 1、seq = x（假设为x）。此时客户端的状态会变成SYN-SENT（同步已发送）
> SYN = 1 表示这是一个TCP连接请求报文字段<br>
> seq = x 数据的初始序号，本身并不携带任何数据信息

2. 服务端被动打开，然后进行监听。监听到客户端发送过来的请求连接报文后，会进行确认，并返回一个确认报文，并把状态变成SYN-RCVD（同步已接收）。该报文有这些字段SYN = 1，ACK = 1（注意，是大写的ACK），seq = y，ack = x+1。


> SYN = 1，效果与第一步一样<br> 
> ACK = 1，表示TCP连接确认请求的报文端，不能携带数据<br>
> ack = x+1，表示对请求连接的seq字段进行确认，并表示需要传输的下一个序号<br>
> seq = y，表示服务端数据的初始序号，同样不带任何数据

3. 当客户端收到服务端的确认报文之后，会发送一个确认请求，并携带ACK = 1，seq = x+1，ack = y+1，并把状态变为ESTABKUSGED（连接已建立）
> 注：此时的seq可以携带数据了，字段的含义与上文所提及的效果是一样的

基于一堆文字给人的视觉震撼导致知识不如脑的情况下，我在这里简要概括一下每次发送报文时所发生的内容

1. 客户端发起连接请求，此时客户端能够确认自身的发送能力是正常的
2. 服务端接收到连接请求报文的时候，并返回一个确认连接的报文。此时服务端能够确认自身的发送能力以及接收能力是正常的。但此时服务端并不能确认客户端能不能收到自己的确认报文信息。
3. 客户端收到服务端的确认连接请求后，确认了自身的接受能力是正常的，并且能接受到服务端所发来的报文。但此时服务端不能确定它自己能否收到客户端，所以需要客户端发送一个确认报文给它。
4. 当服务端接收到客户端的确认报文后，服务端就知道了客户端能够收到它的消息，所以此时就可以愉快的传输数据了。

什么？还记不住？那举个例子吧

比如说A和B，分别表示客户端和服务端。
- A拨打电话给B，B接听后，A说：能不能听见我说话？
- B：听到了，你能听见我说话吗？
- A：能听到，今晚五排！

> A拨打电话给B，这一步就是连接请求报文<br>
> B接听后，听到A的话后，说自己能听到A说话，问A能不能听见B说话，这一步就是服务端发送确认连接报文<br>
> A听到B问他能不能听见他说话，就回他能听到，这一步就是对服务端的确认报文的确认，并且说今晚五排，这里代表的就是客户端在第三次握手的时候所携带信息

emmm...如果还是不能理解的话，多看看几遍就好了0v0

那然后就有个问题，为啥要三次，两次不行？这个问题其实上面的概括就可以回答了。

当然还有另外的回答。如果服务端没有收到客户端的确认连接报文的确认报文（可能丢失会网络阻塞），这必然会导致客户端的超时重传。

如果是丢失还好，那如果是由于网络阻塞，导致确认报文超过了定时器（超时重传）的时间，然后客户端发送新的连接确认报文，然后此时服务端收到了新的确认报文，然后传输数据。然后假设传输后，客户端关闭连接，而此时被阻塞的确认报文传到了服务端，服务端就会误以为客户端要连接了，就被动开启，又因为此时客户端已经关闭了，此时没有进行连接，那此时服务端就白白浪费了资源。所以需要三次握手。

什么？又因为字太多不想看？那就以上面打电话的例子来讲吧。

前面两步是一样的，主要看第三次
- A：能听到，今晚五排！
诶，此时信号不好，然后A又说了一句，此时B听到了，然后后面吧啦吧啦后，挂断了。

然后假设过了几天，B的手机突然收到了A延迟的信息，以为A又打电话给他，然后就保持着连接，然后B又想着A这个叼毛打电话过来又不说话？然后B就一直等...

上面的假设仅用于解释说明，不要照应到现实中0v0




### 四次挥手
