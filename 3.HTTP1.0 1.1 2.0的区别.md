### http 1.0
> 支持:POST/GET/HEAD 方法<br>
> 无状态：服务器不跟踪不记录请求过的状态<br>
> 无连接（短连接）：浏览器每次请求都需要建立tcp连接<br>
>
> - HTTP/1.0规定浏览器和服务器保持短暂的连接。浏览器的每次请求都需要与服务器建立一个TCP连接，服务器处理完成后立即断开TCP连接（无连接），服务器不跟踪每个客户端也不记录过去的请求（无状态）
> 可以借助cookie/session机制来做身份认证和记录状态
> 但是无连接特性会导致以下性能问题：<br>
> 1. 无法复用连接。每次请求的时候都需要进行一次tcp连接(三握四挥),导致网络的利用率很低<br>
> 注：http1.0也可以开启长连接，通过在请求头Connection:Keep-alive启用长连接请求，但这个并不是1.0的标准字段
> 2. 队头阻塞。由于http1.0规定下一次请求必须在前一次请求得到响应之后才能进行，如果前一次请求一直没有响应，就会一直阻塞后面的请求

为了解决http1.0所遗留的问题,推出了http1.1
### http1.1
> 相比于1.0，1.1新增了OPTIONS/PUT/PATCH/DELETE/TRACE/CONNECT方法
> - HTTP1.1现在已经支持长连接了，新增了一个Connection字段用于开启长连接，通过`keep-alive:true`开启（默认就是开启的），如果需要关闭长连接，可以在请求头添加`Connection:false`关闭
> - 支持请求并行化（没啥吊用）。即把客户端的请求队列的模式（请求是先进先出的）前移到服务端， 即响应也是先进先出的，比如客户端发送了两个请求html和css，
即使服务端先加载完css资源，也得等html资源处理完响应会客户端后才会发送css给客户端。
> 值得一提的是，可以在谷歌浏览器中的控制台看到并行请求，这其实是开启了多个TCP连接进行数据传输，这种方式与http1.1的请求并行化相比，前者才算是真正的并行
> - http1.1新增了缓存字段，比如强协商的Cache-control、以及协商缓存的ETag。用于优化http1.0的强协商缓存Expires的问题，以及协商缓存Last_Modified，即如果同时设置了两个缓存字段，会默认使用http1.1的缓存字段，无视http1.0的字段
但是依旧没有解决对头阻塞的问题，这其实与TCP协议有关，如果要解决对头阻塞

