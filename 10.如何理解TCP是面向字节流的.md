## 如何理解TCP是面向字节流的？
在考虑这个问题之前，首先要知道TCP是怎么处理应用层交付过来的数据？

### TCP怎么处理应用层交付过来的数据
在应用层中，有好几个协议都是基于TCP的

比如
- HTTP、
- FTP（文件传输）
- SMTP（简单邮件传输）
- TELNET（远程登录）
- ...

如果要根据这些协议，去处理成对应的报文，那效率是非常低下的，并且报文的通用性低，而且以后如果有新的应用层协议需要基于TCP，那是不是还得继续去编写对应的报文？

所以，TCP在设计的时候就考虑到这些，然后就这样弄：你应用层不管是基于哪个协议传下来的报文，我TCP都不考虑，我只知道你传给我的是一串无结构的字节流。然后就对这一串字节流进行处理。

因为TCP把应用层交付的数据当做一串无结构的字节流，也因此可以认为TCP是面向字节流的。

那么新的问题就来了，TCP是怎么根据这些字节流去处理成TCP报文的？

### TCP如何处理字节流
以http报文为例吧，比如说客户端要发送这么两个消息，`Hello`、`I'm world`

当发送端，调用一个send函数（假设有这么个函数）进行发送后，此时数据并没有真正的发送出去，只是将这个数据拷贝到一个发送缓冲区中。

至于什么时候发送，取决于当前的TCP发送窗口、拥塞窗口以及发送缓冲区等条件。

注：TCP的发送窗口的单位是字节

考虑到实际情况后，通过调用send函数陆续发送`Hello`、`I'm world`，可能会出现以下几种情况

- 两个消息被封装在一个TCP报文中
![](%E7%90%86%E8%A7%A3TCP%E5%AD%97%E8%8A%82%E6%B5%811.jpg)

- I'm world部分内容与Hello内容在同个报文中，像这样
![](%E7%90%86%E8%A7%A3TCP%E5%AD%97%E8%8A%82%E6%B5%812.jpg)

- Hello部分内容作为一个报文发送出去，另一部分与I'm world作为另外一个报文发送出去，像这样
![](%E7%90%86%E8%A7%A3TCP%E5%AD%97%E8%8A%82%E6%B5%813.jpg)

类似这种情况的还有好多种，这里只是想说明，我们并不知道TCP会怎么对`Hello`和`I'm world`这两个信息进行分组。

因此，我们不能认为一个用户信息对应一个TCP报文，也正因为这样，所以TCP是面向字节流的（可以通过这方面去理解TCP面向字节流）。

### 粘包
粘包的问题，就是因为TCP不知道用户消息的边界，把两个（多个）消息的部分内容分到一个TCP报文中。如果接收方不知道消息边界的话，是无法读取出有效信息的。

因为TCP只知道数据是一串字节流，所以要处理粘包信息，只能在<b>应用层</b>中处理

### 粘包的处理方法
1. 固定消息长度
2. 特殊字符作为边界
3. 自定义消息结构

#### 固定消息长度
这种是最简单的方法，规定每次发送消息的长度是固定的，比如说64个字节，
当接收方收到64个字节后，就认为是一个完整且有效的信息

灵活度不高，不常用

#### 特殊字符作为边界值
我们可以在两个用户消息之间插入一个特殊的字符串，这样接收方在接收数据时，读到了这个特殊字符，就把认为已经读完一个完整的消息。

有一点要注意，这个作为边界点的特殊字符，如果刚好消息内容里有这个特殊字符，我们要对这个字符转义，避免被接收方当作消息的边界点而解析到无效的数据。


